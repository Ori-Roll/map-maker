{"version":3,"sources":["helpers/index.js","App.js","shapes/mountains.js","serviceWorker.js","index.js"],"names":["calcObjectsDistance","objA","objB","Math","sqrt","x","y","calcPointHeight","point","mountainsArr","pointGroundHeight","pointIsOnMtnKey","forEach","mtn","pointToMtnDistance","spread","pointHeightInMtn","height","key","mountains","canvasSize","width","App","canvas","useRef","useState","mtnsAmount","mtnClampiness","heightFactor","mtnsHeight","makeCanvas","canvasRef","ctx","current","getContext","newMtnsArr","i","proposedMtnX","random","proposedMtnY","pointHeight","mtnProbability","console","log","newKey","newX","newY","newSpread","floor","newHeight","newZ","push","z","makeMtnArr","sort","a","b","mtnObj","beginPath","moveTo","lineTo","lineWidth","strokeStyle","stroke","fillStyle","fill","mtnShape","pMap","precipitationMap","Array","xPos","pointsDistance","yPos","mtnsWithBigSpread","map","item","position","precipitation","reduce","waterBalance","length","getPointNeighbors","pointArr","aboveIndex","findIndex","neighbor","belowIndex","onRightIndex","onLeftIndex","above","below","onRight","right","onLeft","left","pMapByHeight","pointNeighbors","allHeightDifference","isNaN","waterParts","pointColorIfWaterAbsorbed","arc","makePrecipitationMap","useEffect","className","ref","style","backgroundColor","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.9b3e6a0a.chunk.js","sourcesContent":["function calcObjectsDistance(objA, objB) {\r\n\treturn Math.sqrt((objA.x - objB.x) ** 2 + (objA.y - objB.y) ** 2);\r\n}\r\n\r\nfunction calcPointHeight(point, mountainsArr) {\r\n\tlet pointGroundHeight = 0;\r\n\tlet pointIsOnMtnKey = 0;\r\n\r\n\tmountainsArr.forEach(mtn => {\r\n\t\tlet pointToMtnDistance = calcObjectsDistance(point, mtn);\r\n\t\tif (pointToMtnDistance < mtn.spread) {\r\n\t\t\tlet pointHeightInMtn = mtn.height * ((mtn.spread - pointToMtnDistance) / mtn.spread);\r\n\t\t\tpointGroundHeight =\r\n\t\t\t\tpointHeightInMtn > pointGroundHeight ? pointHeightInMtn : pointGroundHeight;\r\n\t\t\tpointIsOnMtnKey = pointHeightInMtn > pointGroundHeight ? mtn.key : pointIsOnMtnKey;\r\n\t\t}\r\n\t});\r\n\treturn { pointGroundHeight: pointGroundHeight, pointIsOnMtnKey: pointIsOnMtnKey };\r\n}\r\n\r\nexport { calcObjectsDistance, calcPointHeight };\r\n\r\n/* \r\nconsole.log(\"-----------valid mountain-----------\");\r\n\t\t\tconsole.log(\"height is :\" + mtn.height);\r\n\t\t\tconsole.log(\"spread is:\" + mtn.spread);\r\n\t\t\tconsole.log(\"pointToMtnDistance is:\" + pointToMtnDistance); \r\n\r\nconsole.log(\"height precent is is \", (mtn.spread - pointToMtnDistance) / mtn.spread);\r\n\t\t\tconsole.log(\"pointHeightInMtn is \", pointHeightInMtn);\r\n */\r\n\r\n/* console.log(\r\n\t\"YEA: \",\r\n\tcalcPointHeight({ x: 10, y: 0 }, [\r\n\t\t{ x: 0, y: 0, height: 20, spread: 40, key: 0 },\r\n\t\t{ x: 20, y: 0, height: 40, spread: 40, key: 1 }\r\n\t])\r\n); */\r\n","import React, { useRef, useEffect, useState } from \"react\";\nimport \"./App.css\";\nimport { calcObjectsDistance, calcPointHeight } from \"./helpers\";\nimport { mtnShape, mtnRangeShape, makeMtnArr } from \"./shapes\";\n\nconst canvasSize = { width: \"1000\", height: \"1000\" };\nlet mountains;\n\nfunction App() {\n\tconst canvas = useRef(null);\n\tconst [mtnsAmount, setMtnsAmount] = useState(30); // APROX 1-60\n\tconst [mtnClampiness, setMtnClampiness] = useState(1.5); // APROX 1-5\n\tconst [heightFactor, setheightFactor] = useState(0.8); // APROX 0-2\n\tconst [mtnsHeight] = useState(mtnsAmount / 30 + heightFactor);\n\n\tfunction makeCanvas(canvasRef) {\n\t\tconst ctx = canvasRef.current.getContext(\"2d\");\n\t\tmountains = makeMtnArr(canvasSize, mtnsAmount, mtnClampiness, mtnsHeight);\n\t\tmountains.sort((a, b) => a.y - b.y);\n\t\tmountains.forEach(mtn => mtnShape(ctx, mtn));\n\n\t\tmakePrecipitationMap(ctx);\n\t}\n\n\tuseEffect(() => {\n\t\tmakeCanvas(canvas);\n\t}, []);\n\n\tfunction makePrecipitationMap(ctx) {\n\t\tlet pointsDistance = 8;\n\t\tconst pMap = [];\n\t\tconst precipitationMap = new Array(6).fill({\n\t\t\tx: Math.random() * canvasSize.width,\n\t\t\ty: Math.random() * canvasSize.height\n\t\t});\n\t\tlet xPos = pointsDistance / 2;\n\t\tlet yPos = pointsDistance / 2;\n\t\tlet mtnsWithBigSpread = mountains.map(item => {\n\t\t\treturn { ...item, spread: item.spread * 4, height: item.height / 2 };\n\t\t});\n\t\tmtnsWithBigSpread = [...mtnsWithBigSpread, ...mountains];\n\t\t// Creates simple array, not a 2D array formation. Works better for this\n\t\tfor (yPos; yPos < ctx.canvas.height; yPos += pointsDistance) {\n\t\t\tfor (xPos; xPos < ctx.canvas.width; xPos += pointsDistance) {\n\t\t\t\tlet position = { x: xPos, y: yPos };\n\t\t\t\tlet height = Math.sqrt(calcPointHeight(position, mtnsWithBigSpread).pointGroundHeight);\n\t\t\t\t/* let precipitation = Math.floor(\n\t\t\t\t\t((Math.random() * precipitationFactor * 25 + height * 35) /\n\t\t\t\t\t\t(precipitationFactor / 0.4)) **\n\t\t\t\t\t\t2\n\t\t\t\t); */\n\t\t\t\tconst precipitation =\n\t\t\t\t\tcalcObjectsDistance(\n\t\t\t\t\t\tprecipitationMap.reduce((a, b) => {\n\t\t\t\t\t\t\treturn a > b ? a : b;\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tposition\n\t\t\t\t\t) / 5000;\n\t\t\t\tlet waterBalance = precipitation;\n\t\t\t\t/* ctx.fillStyle = `rgba(0,0,255,${precipitation / 1000}`; */\n\t\t\t\t/* ctx.fillRect(position.x - 2, position.y - 2, 4, 4); */\n\n\t\t\t\tpMap.push({\n\t\t\t\t\tposition: position,\n\t\t\t\t\theight: height,\n\t\t\t\t\tprecipitation: precipitation,\n\t\t\t\t\twaterBalance: waterBalance\n\t\t\t\t});\n\n\t\t\t\tpMap[pMap.length - 1].getPointNeighbors = getPointNeighbors;\n\t\t\t}\n\n\t\t\txPos = pointsDistance / 2;\n\t\t}\n\n\t\tfunction getPointNeighbors(point, pointArr) {\n\t\t\t/* console.log(\"getPointNeighbor, pointArr is\", pointArr);\n\t\t\tconsole.log(\"getPointNeighbor, index\", point); */\n\t\t\tlet aboveIndex = pointArr.findIndex(neighbor => {\n\t\t\t\treturn (\n\t\t\t\t\tneighbor.position.y === point.position.y - pointsDistance &&\n\t\t\t\t\tneighbor.position.x === point.position.x\n\t\t\t\t);\n\t\t\t});\n\t\t\tlet belowIndex = pointArr.findIndex(neighbor => {\n\t\t\t\treturn (\n\t\t\t\t\tneighbor.position.y === point.position.y + pointsDistance &&\n\t\t\t\t\tneighbor.position.x === point.position.x\n\t\t\t\t);\n\t\t\t});\n\t\t\tlet onRightIndex = pointArr.findIndex(neighbor => {\n\t\t\t\treturn (\n\t\t\t\t\tneighbor.position.y === point.position.y &&\n\t\t\t\t\tneighbor.position.x === point.position.x + pointsDistance\n\t\t\t\t);\n\t\t\t});\n\t\t\tlet onLeftIndex = pointArr.findIndex(neighbor => {\n\t\t\t\treturn (\n\t\t\t\t\tneighbor.position.y === point.position.y &&\n\t\t\t\t\tneighbor.position.x === point.position.x - pointsDistance\n\t\t\t\t);\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tabove: pointArr[aboveIndex] ? pointArr[aboveIndex] : \"none\",\n\t\t\t\tbelow: pointArr[belowIndex] ? pointArr[belowIndex] : \"none\",\n\t\t\t\tonRight: pointArr[onRightIndex] ? pointArr[onRightIndex] : \"none\",\n\t\t\t\tright: pointArr[onRightIndex] ? pointArr[onRightIndex] : \"none\",\n\t\t\t\tonLeft: pointArr[onLeftIndex] ? pointArr[onLeftIndex] : \"none\",\n\t\t\t\tleft: pointArr[onLeftIndex] ? pointArr[onLeftIndex] : \"none\"\n\t\t\t};\n\t\t}\n\n\t\t/* console.log(\"getPointNeighbors\", getPointNeighbors(151, pMap)); */\n\n\t\tconst pMapByHeight = [...pMap].sort((a, b) => {\n\t\t\treturn a.height >= b.height ? -1 : 1;\n\t\t});\n\n\t\tfunction waterFlow() {\n\t\t\txPos = pointsDistance / 2;\n\t\t\tyPos = pointsDistance / 2;\n\n\t\t\tpMapByHeight.forEach(point => {\n\t\t\t\tconst pointNeighbors = [\n\t\t\t\t\tpoint.getPointNeighbors(point, pMap).above,\n\t\t\t\t\tpoint.getPointNeighbors(point, pMap).below,\n\t\t\t\t\tpoint.getPointNeighbors(point, pMap).right,\n\t\t\t\t\tpoint.getPointNeighbors(point, pMap).left\n\t\t\t\t];\n\t\t\t\tlet allHeightDifference = 0;\n\t\t\t\tpointNeighbors.forEach(item => {\n\t\t\t\t\tif (!isNaN(item.height) && item.height < point.height) {\n\t\t\t\t\t\tallHeightDifference += point.height - item.height;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tlet waterParts = point.height ? point.waterBalance / allHeightDifference : 0;\n\t\t\t\twaterParts = waterParts > 0 && waterParts < 700 ? waterParts : 1;\n\n\t\t\t\tpointNeighbors.forEach(neighbor => {\n\t\t\t\t\tif (neighbor !== \"none\" && neighbor.height <= point.height) {\n\t\t\t\t\t\tneighbor.waterBalance += waterParts * (point.height - neighbor.height);\n\t\t\t\t\t\tpoint.waterBalance -= neighbor.waterBalance / (0.4 / (point.height - neighbor.height));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t/* console.log(point.waterBalance); */\n\t\t\t});\n\t\t}\n\t\t/* console.log(pMap); */\n\t\twaterFlow();\n\t\t/* console.log(pMapByHeight); */\n\t\tpMapByHeight.forEach(point => {\n\t\t\tlet pointColorIfOverflow = `rgba(100, 121, 140,0.8)`;\n\t\t\tlet pointColorIfWaterAbsorbed = `rgba(152, 168, 114,${point.waterBalance * 0.1})`;\n\t\t\tlet overflowThreshold = 8;\n\t\t\tctx.fillStyle =\n\t\t\t\tpoint.waterBalance > overflowThreshold ? pointColorIfOverflow : pointColorIfWaterAbsorbed;\n\n\t\t\tif (point.waterBalance > overflowThreshold) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(\n\t\t\t\t\tpoint.position.x + Math.random() * 4 - Math.random() * 4,\n\t\t\t\t\tpoint.position.y + Math.random() * 4 - Math.random() * 4 - point.height * 2,\n\t\t\t\t\t4,\n\t\t\t\t\t0,\n\t\t\t\t\t360\n\t\t\t\t);\n\t\t\t\tctx.fill();\n\t\t\t} else if (\n\t\t\t\tpoint.waterBalance < overflowThreshold &&\n\t\t\t\tMath.random() + 1 > 2.3 / point.waterBalance\n\t\t\t) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(\n\t\t\t\t\tpoint.position.x + Math.random() * 4 - Math.random() * 4,\n\t\t\t\t\tpoint.position.y + Math.random() * 4 - Math.random() * 4 - point.height * 2,\n\t\t\t\t\t8,\n\t\t\t\t\t0,\n\t\t\t\t\t360\n\t\t\t\t);\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t});\n\t}\n\n\treturn (\n\t\t<div className='App'>\n\t\t\t<canvas\n\t\t\t\tref={canvas}\n\t\t\t\tstyle={{ backgroundColor: \"#c2bb99\" }}\n\t\t\t\twidth={canvasSize.width}\n\t\t\t\theight={canvasSize.width}></canvas>\n\t\t</div>\n\t);\n}\n\nexport default App;\n\n/* for (let j = 0; j < (canvasSize.width * canvasSize.height) / 3000; j++) {\n\tconst proposedMtnX = Math.random() * canvasSize.width;\n\tconst proposedMtnY = Math.random() * canvasSize.height;\n\tconst pointHeight = calcPointHeight({ x: proposedMtnX, y: proposedMtnY }, mtnRanges);\n\tconst mtnProbability = pointHeight.pointGroundHeight;\n\n\tif (mtnProbability > 39) {\n\t\tmountains.push({\n\t\t\tx: proposedMtnX,\n\t\t\ty: proposedMtnY,\n\t\t\theight: Math.random() * 5 + 5,\n\t\t\tspread: Math.random() * 5 + 5,\n\t\t\tkeyOfMtnRange: pointHeight.pointIsOnMtnKey,\n\t\t\tkey: j\n\t\t});\n\t\tmountains[mountains.length - 1].z = Math.floor(mountains[mountains.length - 1].y);\n\t}\n}\n\nmountains.forEach(mtn => mtnRangeShape(ctx, mtn));\n */\n\n/* let thirdMtn = { x: 500, y: 500 };\n\t\tthirdMtn.height = 100;\n\t\tthirdMtn.spread = 100;\n\t\tmtnShape(ctx, thirdMtn); */\n/* let aa = calcObjectsDistance(mountains[0], mountains[1]); */\n","import { calcPointHeight, calcObjectsDistance } from \"../helpers\";\r\n\r\nexport function makeMtnArr(canvasSize, mtnsAmount, mtnClampiness, mtnsHeight) {\r\n\tconst newMtnsArr = [];\r\n\r\n\tfor (let i = 0; i < (canvasSize.width * canvasSize.height * mtnsAmount) / 80000; i++) {\r\n\t\tconst proposedMtnX = Math.random() * canvasSize.width;\r\n\t\tconst proposedMtnY = Math.random() * canvasSize.height;\r\n\t\tconst pointHeight = calcPointHeight({ x: proposedMtnX, y: proposedMtnY }, newMtnsArr);\r\n\t\tconst mtnProbability =\r\n\t\t\tMath.random() * 10 + pointHeight.pointGroundHeight * 2 + 3000 / mtnClampiness / i;\r\n\t\tconst tooCloseToOtherMtn = (() => {\r\n\t\t\tif (newMtnsArr[pointHeight.pointIsOnMtnKey]) {\r\n\t\t\t\t/* console.log(newMtnsArr); */\r\n\t\t\t\tif (\r\n\t\t\t\t\tcalcObjectsDistance(\r\n\t\t\t\t\t\t{ x: proposedMtnX, y: proposedMtnY },\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tx: newMtnsArr[pointHeight.pointIsOnMtnKey].x,\r\n\t\t\t\t\t\t\ty: newMtnsArr[pointHeight.pointIsOnMtnKey].y\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t) < 80\r\n\t\t\t\t) {\r\n\t\t\t\t\tconsole.log(\"too close\");\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log(\"its 0\");\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t})();\r\n\t\tif (mtnProbability > 40 /* && tooCloseToOtherMtn */) {\r\n\t\t\tconst newKey = i;\r\n\t\t\tconst newX = proposedMtnX;\r\n\t\t\tconst newY = proposedMtnY;\r\n\t\t\tconst newSpread = Math.floor(Math.random() * 64 + 16);\r\n\t\t\tconst newHeight = (Math.random() + 2) * mtnsHeight * (newSpread / 8) + 5; // MAKE AFFECTED BY INITIAL HEIGHT !!!\r\n\t\t\tconst newZ = Math.floor(newY);\r\n\r\n\t\t\tnewMtnsArr.push({\r\n\t\t\t\tkey: newKey,\r\n\t\t\t\tx: newX,\r\n\t\t\t\ty: newY,\r\n\t\t\t\tz: newZ,\r\n\t\t\t\tspread: newSpread,\r\n\t\t\t\theight: newHeight\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\treturn newMtnsArr;\r\n}\r\n\r\nexport function mtnShape(ctx, mtnObj) {\r\n\tif (typeof mtnObj !== \"object\") {\r\n\t\tconsole.log(\"no mtnObj provided\");\r\n\t}\r\n\r\n\tlet height = mtnObj.height ? mtnObj.height : 40;\r\n\tlet spread = mtnObj.spread ? mtnObj.spread : 100;\r\n\tlet x = mtnObj.x ? mtnObj.x : 100;\r\n\tlet y = mtnObj.y ? mtnObj.y : 100;\r\n\r\n\tctx.beginPath();\r\n\tctx.moveTo(x - spread / 2, y);\r\n\tctx.lineTo(x, y - height);\r\n\tctx.lineTo(x + spread / 2, y);\r\n\tctx.lineWidth = 6;\r\n\tctx.strokeStyle = \"#968372\";\r\n\tctx.stroke();\r\n\tctx.fillStyle = \"#c2bb99\";\r\n\tctx.fill();\r\n}\r\n\r\n/* let mtnGradient = ctx.createRadialGradient(110, 90, 30, 100, 100, 70);\r\n\tmtnGradient.addColorStop(0, \"rgba(255, 255, 255)\");\r\n\tmtnGradient.addColorStop(0.7, \"lightGray\");\r\n\tmtnGradient.addColorStop(0.9, \"rgba(0, 0, 0)\");\r\n\tctx.fillStyle = mtnGradient;\r\n\tctx.strokeRect(x, y, spread, spread); */\r\n\r\n/* import React, { useState, useEffect } from \"react\";\r\n\r\nfunction mountain() {\r\n    const mtnSize = useState(10);\r\n    const mtnPosition = useState(100, 100);\r\n\r\n    useEffect(\r\n        ()=>{}\r\n        ,[mtnSize, mtnPosition]\r\n    )\r\n}\r\n */\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}